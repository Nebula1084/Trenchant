<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

		<script type="text/javascript" src="js/Trenchant.js"></script>
        <script type="text/javascript" src="js/obj/Object.js"></script>
        <script type="text/javascript" src="js/mtl/Material.js"></script>
        <script type="text/javascript" src="js/shader/PhongShader.js"></script>
        <script type="text/javascript" src="js/shader/Cook_Torrance.js"></script>
        <script type="text/javascript" src="js/shader/Torrance_Sparrow.js"></script>
        <script type="text/javascript" src="js/shader/VertexShader.js"></script>
        <script type="text/javascript" src="js/loaders/OBJLoader.js"></script>
		<script type="text/javascript" src="js/libs/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="js/libs/webgl-utils.js"></script>
		<script type="text/javascript" src="js/libs/jquery.min.js"></script>
		<script type="text/javascript" src="js/nurbs/NURBSSurface.js"></script>
		<script type="text/javascript" src="js/nurbs/NURBSUtils.js"></script>

		<script id="per-fragment-lighting-fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec2 vTextureCoord;

			uniform sampler2D uSampler;

			void main(void) {
				gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
			}
		</script>

		<script id="per-fragment-lighting-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;

			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;

			varying vec2 vTextureCoord;

			void main(void) {
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vTextureCoord = aTextureCoord;
			}
		</script>


	<script type="text/javascript">

	var gl;

	function initGL(canvas) {
		try {
			gl = canvas.getContext("experimental-webgl");
			gl.viewportWidth = canvas.width;
			gl.viewportHeight = canvas.height;
		} catch (e) {
		}
		if (!gl) {
			alert("Could not initialise WebGL, sorry :-(");
		}
	}


	function getShader(gl, id) {
		var shaderScript = document.getElementById(id);
		if (!shaderScript) {
			return null;
		}

		var str = "";
		var k = shaderScript.firstChild;
		while (k) {
			if (k.nodeType == 3) {
				str += k.textContent;
			}
			k = k.nextSibling;
		}

		var shader;
		if (shaderScript.type == "x-shader/x-fragment") {
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex") {
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			return null;
		}

		gl.shaderSource(shader, str);
		gl.compileShader(shader);

		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			alert(gl.getShaderInfoLog(shader));
			return null;
		}

		return shader;
	}

	var shaderProgram;


    function initShaders() {
		var fragmentShader = getShader(gl, "per-fragment-lighting-fs");
		var vertexShader = getShader(gl, "per-fragment-lighting-vs");

		shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert("Could not initialise shaders");
		}

		gl.useProgram(shaderProgram);

		shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
		gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

		shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
		gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

		shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
		shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
		shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
    }


    function handleLoadedTexture(texture, type) {
		switch (type) {
			case 0:
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
				//gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
				gl.generateMipmap(gl.TEXTURE_2D);

				gl.bindTexture(gl.TEXTURE_2D, null);
				break;
			case 1:
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.bindTexture(gl.TEXTURE_2D, null);
				break;
		}

    }

	var skyTexture;
    var grassTexture;
    var road0Texture;
	var road1Texture;
	var treeTexture = [];

	var _UP = 3;
	var _DOWN = 4;
	var _LEFT = 5;
	var _RIGHT = 6;
	var _FRONT = 7;
	var _BACK = 8;

    function initTexture() {
		// type 0
        grassTexture = gl.createTexture();
        grassTexture.image = new Image();
        grassTexture.image.onload = function() {
            handleLoadedTexture(grassTexture, 0);
        }
		grassTexture.image.src = "textures/grass.jpg";

		// type 1
		road0Texture = gl.createTexture();
		road0Texture.image = new Image();
		road0Texture.image.onload = function() {
			handleLoadedTexture(road0Texture, 0);
		}
		road0Texture.image.src = "textures/road0.jpg"

		// type 2
		road1Texture = gl.createTexture();
		road1Texture.image = new Image();
		road1Texture.image.onload = function() {
			handleLoadedTexture(road1Texture, 0);
		}
		road1Texture.image.src = "textures/road1.jpg"

		skyTexture = new Object();
		skyTexture.id = 1;

		// type 3
		skyTexture.up = gl.createTexture();
		skyTexture.up.image = new Image();
		skyTexture.up.image.onload = function() {
			handleLoadedTexture(skyTexture.up, 1);
		}
		skyTexture.up.image.src = "textures/skyCube/" + skyTexture.id + "/up.jpg";

		// type 4
		skyTexture.down = gl.createTexture();
		skyTexture.down.image = new Image();
		skyTexture.down.image.onload = function() {
			handleLoadedTexture(skyTexture.down, 1);
		}
		skyTexture.down.image.src = "textures/skyCube/" + skyTexture.id + "/down.jpg";

		// type 5
		skyTexture.left = gl.createTexture();
		skyTexture.left.image = new Image();
		skyTexture.left.image.onload = function() {
			handleLoadedTexture(skyTexture.left, 1);
		}
		skyTexture.left.image.src = "textures/skyCube/" + skyTexture.id + "/left.jpg";

		// type 6
		skyTexture.right = gl.createTexture();
		skyTexture.right.image = new Image();
		skyTexture.right.image.onload = function() {
			handleLoadedTexture(skyTexture.right, 1);
		}
		skyTexture.right.image.src = "textures/skyCube/" + skyTexture.id + "/right.jpg";

		// type 7
		skyTexture.front = gl.createTexture();
		skyTexture.front.image = new Image();
		skyTexture.front.image.onload = function() {
			handleLoadedTexture(skyTexture.front, 1);
		}
		skyTexture.front.image.src = "textures/skyCube/" + skyTexture.id + "/front.jpg";

		// type 8
		skyTexture.back = gl.createTexture();
		skyTexture.back.image = new Image();
		skyTexture.back.image.onload = function() {
			handleLoadedTexture(skyTexture.back, 1);
		}
		skyTexture.back.image.src = "textures/skyCube/" + skyTexture.id + "/back.jpg";

		treeTexture = [];
		for (var i=0; i<2; ++i) {
			treeTexture[i] = gl.createTexture();
			treeTexture[i].image = new Image();
			treeTexture[i].image.onload = finish(i);
			function finish(x) {
			    return function(){
			        handleLoadedTexture(treeTexture[x], 0);
			    }
			}
			treeTexture[i].image.src = "textures/tree" + i + ".png";
		}
    }

    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }

    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
    }

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

	var currentlyPressedKeys = {};

    function handleKeyDown(event) {
        currentlyPressedKeys[event.keyCode] = true;
    }


    function handleKeyUp(event) {
        currentlyPressedKeys[event.keyCode] = false;
    }


    var pitch = 0;
    var pitchRate = 0;

    var yaw = 0;
    var yawRate = 0;

    var xPos = 0;
    var yPos = 0.4;
    var zPos = 0;

    var speed = 0;

    function handleKeys() {
        if (currentlyPressedKeys[33]) {
            // Page Up
            pitchRate = 0.1;
        } else if (currentlyPressedKeys[34]) {
            // Page Down
            pitchRate = -0.1;
        } else {
            pitchRate = 0;
        }

        if (currentlyPressedKeys[37] || currentlyPressedKeys[65]) {
            // Left cursor key or A
            yawRate = 0.1;
        } else if (currentlyPressedKeys[39] || currentlyPressedKeys[68]) {
            // Right cursor key or D
            yawRate = -0.1;
        } else {
            yawRate = 0;
        }

        if (currentlyPressedKeys[38] || currentlyPressedKeys[87]) {
            // Up cursor key or W
            speed = 0.003;
        } else if (currentlyPressedKeys[40] || currentlyPressedKeys[83]) {
            // Down cursor key
            speed = -0.003;
        } else {
            speed = 0;
        }

    }


	var worldVertexPositionBuffer = null;
	var worldVertexTextureCoordBuffer = null;

	function handleLoadedWorld(data) {
		var vertexCount = [];
		var vertexPositions = [];
		var vertexTextureCoords = [];

		var skyCube = new Object();
		skyCube.x = 100;
		skyCube.y = 100;
		skyCube.z = 100;

		var x = 20;
		var z = 20;
		var worldFloorType = []; // 0->grass 1->road0 2-> road1
		var worldFloorOrie = []; // Clockwise rotation 0->0 1->90 2->180 3->270

		for (var i = 0; i < 9; i++) {
			vertexCount[i] = 0;
			vertexPositions[i] = [];
			vertexTextureCoords[i] = [];
		}

		var triangleOrder = [1, 0, 3, 1, 2, 3];

		var obj = JSON.parse(data);
		var init = obj.init;
		// window.obj = obj;
		var map = obj.map;

		var skyCubeVertexPosition = obj.skyCubeVertexPosition;
		var skyCubeTriangleOrider = [];
		skyCubeTriangleOrider[_UP] = obj.skyCubeTriangleOrider.up;
		skyCubeTriangleOrider[_DOWN] = obj.skyCubeTriangleOrider.down;
		skyCubeTriangleOrider[_LEFT] = obj.skyCubeTriangleOrider.left;
		skyCubeTriangleOrider[_RIGHT] = obj.skyCubeTriangleOrider.right;
		skyCubeTriangleOrider[_FRONT] = obj.skyCubeTriangleOrider.front;
		skyCubeTriangleOrider[_BACK] = obj.skyCubeTriangleOrider.back;

		for (var i=3; i<9; i++) {
			for (var k in skyCubeTriangleOrider[i]) {
				var order = skyCubeTriangleOrider[i][k];
				var _order = triangleOrder[k];

				vertexPositions[i].push(skyCubeVertexPosition[order].x * skyCube.x);
				vertexPositions[i].push(skyCubeVertexPosition[order].y * skyCube.y);
				vertexPositions[i].push(skyCubeVertexPosition[order].z * skyCube.z);

				vertexTextureCoords[i].push(init[_order].s);
				vertexTextureCoords[i].push(init[_order].t);

				vertexCount[i]++;
			}
		}

		for (var i = -x; i < x; i++) {
			worldFloorType[i] = [];
			worldFloorOrie[i] = [];
			for (var j = -z; j < z; j++) {
				worldFloorType[i][j] = 0;
				worldFloorOrie[i][j] = 0;
			}
		}

		for (var i in map) {
			var _x = map[i].x;
			var _z = map[i].z;
			worldFloorType[_x][_z] = map[i].type;
			worldFloorOrie[_x][_z] = map[i].orientation;
		}

		var ratio = 10;

		for (var i = -x; i < x; i++) {
			for (var j = -z; j < z; j++) {
				type = worldFloorType[i][j];
				orie = worldFloorOrie[i][j];
				for (var k in triangleOrder) {
					var order = triangleOrder[k];
					vertexPositions[type].push((i + init[order].x) * ratio);
					vertexPositions[type].push(0);
					vertexPositions[type].push((j + init[order].z) * ratio);

					vertexTextureCoords[type].push(init[(order + 4 - orie) % 4].s);
					vertexTextureCoords[type].push(init[(order + 4 - orie) % 4].t);

					vertexCount[type]++;
				}
			}
		}

		worldVertexPositionBuffer = [];
		worldVertexTextureCoordBuffer = [];
		for (var i = 0; i < 9; i++) {
			worldVertexPositionBuffer[i] = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer[i]);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions[i]), gl.STATIC_DRAW);
			worldVertexPositionBuffer[i].itemSize = 3;
			worldVertexPositionBuffer[i].numItems = vertexCount[i];

	        worldVertexTextureCoordBuffer[i] = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer[i]);
	        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoords[i]), gl.STATIC_DRAW);
	        worldVertexTextureCoordBuffer[i].itemSize = 2;
	        worldVertexTextureCoordBuffer[i].numItems = vertexCount[i];
		}
	}


	var treesVertexPositionBuffer = null;
	var treesVertexTextureCoordBuffer = null;
	var treesPosition = null;

	function handleLoadedTrees(data) {
		treesVertexPositionBuffer = [];
		treesVertexTextureCoordBuffer = [];

		var obj = JSON.parse(data);
		treesPosition = obj.treesPos;
		//console.log(treesPosition);
		var treeNum = treesPosition.length;

		for (var i in treesPosition) {
			//var x = treesPosition[i].x;
			var y = treesPosition[i].y;
			//var z = treesPosition[i].z;
			var x = 0;
			var z = 0;
			var width = treesPosition[i].width;
			var treesVertexPosition = [];
			var treesVertexTextureCoord = [];

			treesVertexPosition.push(x - width);
			treesVertexPosition.push(y);
			treesVertexPosition.push(z);

			treesVertexPosition.push(x - width);
			treesVertexPosition.push(-0.2);
			treesVertexPosition.push(z);

			treesVertexPosition.push(x + width);
			treesVertexPosition.push(-0.2);
			treesVertexPosition.push(z);

			treesVertexPosition.push(x - width);
			treesVertexPosition.push(y);
			treesVertexPosition.push(z);

			treesVertexPosition.push(x + width);
			treesVertexPosition.push(y);
			treesVertexPosition.push(z);

			treesVertexPosition.push(x + width);
			treesVertexPosition.push(-0.2);
			treesVertexPosition.push(z);

			treesVertexTextureCoord.push(1);
			treesVertexTextureCoord.push(1);

			treesVertexTextureCoord.push(1);
			treesVertexTextureCoord.push(0);

			treesVertexTextureCoord.push(0);
			treesVertexTextureCoord.push(0);

			treesVertexTextureCoord.push(1);
			treesVertexTextureCoord.push(1);

			treesVertexTextureCoord.push(0);
			treesVertexTextureCoord.push(1);

			treesVertexTextureCoord.push(0);
			treesVertexTextureCoord.push(0);

			console.log(treesVertexPosition);
			console.log(treesVertexTextureCoord);
			treesVertexPositionBuffer[i] = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, treesVertexPositionBuffer[i]);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(treesVertexPosition), gl.STATIC_DRAW);
			treesVertexPositionBuffer[i].itemSize = 3;
			treesVertexPositionBuffer[i].numItems = 6;

			treesVertexTextureCoordBuffer[i] = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, treesVertexTextureCoordBuffer[i]);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(treesVertexTextureCoord), gl.STATIC_DRAW);
			treesVertexTextureCoordBuffer[i].itemSize = 2;
			treesVertexTextureCoordBuffer[i].numItems = 6;
		}
	}

	function loadWorld() {
		var request = new XMLHttpRequest();
		request.open("GET", "data/world.json");
		request.onreadystatechange = function() {
			if (request.readyState == 4) {
				handleLoadedWorld(request.responseText);
			}
		}

		request.send();
	}

	function loadTrees() {
		var request = new XMLHttpRequest();
		request.open("GET", "data/tree.json");
		request.onreadystatechange = function() {
			if (request.readyState == 4) {
				handleLoadedTrees(request.responseText);
			}
		}

		request.send();
	}

    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

		if (worldVertexTextureCoordBuffer == null || worldVertexPositionBuffer == null) {
		    return;
		}
		mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, pMatrix);

        mat4.identity(mvMatrix);

		mat4.translate(mvMatrix, [0.0, -0.4, 0]);
		mat4.rotate(mvMatrix, degToRad(-pitch), [1, 0, 0]);
		mat4.rotate(mvMatrix, degToRad(-yaw), [0, 1, 0]);
		mat4.translate(mvMatrix, [-xPos, -yPos, -zPos]);

		mvPushMatrix();
        gl.activeTexture(gl.TEXTURE0);
		for (var i = 0; i < 9; i++) {
			switch (i) {
				case 0:
					gl.bindTexture(gl.TEXTURE_2D, grassTexture);
					break;
				case 1:
					gl.bindTexture(gl.TEXTURE_2D, road0Texture);
					break;
				case 2:
					gl.bindTexture(gl.TEXTURE_2D, road1Texture);
					break;
				case _UP:
					gl.bindTexture(gl.TEXTURE_2D, skyTexture.up);
					break;
				case _DOWN:
					gl.bindTexture(gl.TEXTURE_2D, skyTexture.down);
					break;
				case _LEFT:
					gl.bindTexture(gl.TEXTURE_2D, skyTexture.left);
					break;
				case _RIGHT:
					gl.bindTexture(gl.TEXTURE_2D, skyTexture.right);
					break;
				case _FRONT:
					gl.bindTexture(gl.TEXTURE_2D, skyTexture.front);
					break;
				case _BACK:
					gl.bindTexture(gl.TEXTURE_2D, skyTexture.back);
					break;

			}
			gl.uniform1i(shaderProgram.samplerUniform, 0);
			gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer[i]);
			gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, worldVertexTextureCoordBuffer[i].itemSize, gl.FLOAT, false, 0, 0);

			gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer[i]);
			gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, worldVertexPositionBuffer[i].itemSize, gl.FLOAT, false, 0, 0);

	        setMatrixUniforms();
			gl.drawArrays(gl.TRIANGLES, 0, worldVertexPositionBuffer[i].numItems);
		}
		mvPopMatrix();
    }

	function getTreeAngle(xx, zz, x, z) {
		if (z <= zz)
			return Math.atan((x - xx) / (z - zz));
		else
			return (Math.atan((x - xx) / (z - zz)) + Math.PI);
	}

	function drawTrees() {
		if (treesVertexPositionBuffer == null || treesVertexPositionBuffer == null) {
		    return;
		}
		gl.activeTexture(gl.TEXTURE0);
		gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
		gl.enable(gl.BLEND);
		for (var i in treesPosition) {
			mvPushMatrix();
				var x = treesPosition[i].x;
				var z = treesPosition[i].z;
				var type = treesPosition[i].type;

				var TreeAngle = getTreeAngle(xPos, zPos, x, z);
				mat4.translate(mvMatrix, [x, 0, z]);
				mat4.rotate(mvMatrix, TreeAngle, [0, 1, 0]);

				gl.bindTexture(gl.TEXTURE_2D, treeTexture[type]);

				gl.uniform1i(shaderProgram.samplerUniform, 0);
				gl.bindBuffer(gl.ARRAY_BUFFER, treesVertexTextureCoordBuffer[i]);
				gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, treesVertexTextureCoordBuffer[i].itemSize, gl.FLOAT, false, 0, 0);

				gl.bindBuffer(gl.ARRAY_BUFFER, treesVertexPositionBuffer[i]);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, treesVertexPositionBuffer[i].itemSize, gl.FLOAT, false, 0, 0);

		        setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLES, 0, treesVertexPositionBuffer[i].numItems);
			mvPopMatrix();
		}
	}


	var lastTime = 0;
    // Used to make us "jog" up and down as we move forward.
    var joggingAngle = 0;

    function animate() {
        var timeNow = new Date().getTime();
        if (lastTime != 0) {
            var elapsed = timeNow - lastTime;

            if (speed != 0) {
                xPos -= Math.sin(degToRad(yaw)) * speed * elapsed;
                zPos -= Math.cos(degToRad(yaw)) * speed * elapsed;

                joggingAngle += elapsed * 0.6; // 0.6 "fiddle factor" - makes it feel more realistic :-)
                yPos = Math.sin(degToRad(joggingAngle)) / 20 + 0.4
            }

            yaw += yawRate * elapsed;
            pitch += pitchRate * elapsed;

        }
        lastTime = timeNow;
    }

    function tick() {
        requestAnimFrame(tick);
		handleKeys();
        drawScene();
		drawTrees();
        animate();
    }

    function webGLStart() {
        var canvas = document.getElementById("trenchant_canvas");
        initGL(canvas);
        initShaders();
		initTexture();
		loadWorld();
		loadTrees();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

		document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;

        tick();
    }

	</script>
	</head>

	<body onload="webGLStart();">

		<canvas id="trenchant_canvas" style="border: none;" width="1400" height="700"></canvas>

	</body>

</html>
